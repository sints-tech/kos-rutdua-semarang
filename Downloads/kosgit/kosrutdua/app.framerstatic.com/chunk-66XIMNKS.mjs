import{u as T}from"https://app.framerstatic.com/chunk-IZV4HDYJ.mjs";import{j as t}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";var v;(e=>e.log=T("\u{1F4A9} fallback-logger-please-reassign:services"))(v||={});(a=>{a._isTesting=!1;let e;async function i(c,d){if(!a._isTesting)throw new Error("ServiceManager.isTesting must be true to use testWithShared()");if(e)throw new Error("ServiceManager.testWithShared() may not be nested");try{return e=c,await d()}finally{e=void 0}}a._testWithShared=i;function s(){if(a._isTesting){if(e)return e;throw new Error("ServiceManager.shared() may not be used while testing. Use testWithShared() for explicitness.")}}a._sharedServiceManagerIfTesting=s})(v||={});function x(n,e){throw e||new Error("Unexpected object: "+n)}var p=class extends Error{constructor(){super(...arguments);t(this,"name","ServiceError.UnknownError");t(this,"code",0);t(this,"status",0);t(this,"skipSentry",!1)}};(m=>{let n;(l=>(l[l.serviceNotFound=404]="serviceNotFound",l[l.serviceNotCompatible=426]="serviceNotCompatible",l[l.serviceGone=410]="serviceGone",l[l.implementation=500]="implementation",l[l.timedOut=504]="timedOut",l[l.badRequest=400]="badRequest",l[l.badResponse=422]="badResponse"))(n=m.Code||={});class e extends m{constructor(){super(...arguments);t(this,"code",404);t(this,"name","ServiceError.ServiceNotFound")}}m.ServiceNotFound=e;class i extends m{constructor(){super(...arguments);t(this,"code",426);t(this,"name","ServiceError.ServiceNotCompatible")}}m.ServiceNotCompatible=i;class s extends m{constructor(){super(...arguments);t(this,"code",410);t(this,"name","ServiceError.ServiceGone");t(this,"skipSentry",!0)}}m.ServiceGone=s;class a extends m{constructor(){super(...arguments);t(this,"code",500);t(this,"name","ServiceError.Implementation")}}m.Implementation=a;class c extends m{constructor(){super(...arguments);t(this,"code",504);t(this,"name","ServiceError.TimedOut")}}m.TimedOut=c;class d extends m{constructor(){super(...arguments);t(this,"code",400);t(this,"name","ServiceError.BadRequest")}}m.BadRequest=d;class S extends m{constructor(u,h){super(u);t(this,"code",422);t(this,"name","ServiceError.BadResponse");t(this,"response");this.response=h}}m.BadResponse=S;function g(r){if(!r)return new S;let o;k(r)&&(o=r.message);let u=P(r.code,o);return I(r)&&(u.code=r.code),E(r)&&(u.stack=r.stack),R(r)&&(u.skipSentry=r.skipSentry),N(r)&&(u.status=r.status),u}m.reconstructErrorResponse=g;function P(r,o){try{let u=r;switch(u){case 404:return new e(o);case 426:return new i(o);case 410:return new s(o);case 500:return new a(o);case 504:return new c(o);case 400:return new d(o);case 422:return new S(o);default:x(u)}}catch{return new m(o)}}function M(r){if(r instanceof m)return{code:r.code,message:r.message,stack:r.stack,skipSentry:r.skipSentry};let o,u,h,b,w;return typeof r=="string"?o=r:k(r)&&(o=r.message),E(r)&&(u=r.stack),R(r)&&(h=r.skipSentry),I(r)&&(b=r.code),N(r)&&(w=r.status),{code:b,message:o,stack:u,skipSentry:h,status:w}}m.toMessageBody=M})(p||={});function k(n){return typeof n=="object"&&n&&"message"in n&&typeof n.message=="string"}function E(n){return typeof n=="object"&&n&&"stack"in n&&typeof n.stack=="string"}function R(n){return typeof n=="object"&&n&&"skipSentry"in n&&typeof n.skipSentry=="boolean"}function I(n){return typeof n=="object"&&n&&"code"in n&&typeof n.code=="number"}function N(n){return typeof n=="object"&&n&&"status"in n&&typeof n.status=="number"}function O(n){v.log.error(n)}var f;(s=>{let n=Math.random;function e(){return`${n()}`}s.generateUniqueId=e;function i(){let a,c,d=new Promise((S,g)=>{a=S,c=g});return d.resolve=a,d.reject=c,d}s.newResolvablePromise=i})(f||={});var C=class{constructor(){t(this,"hook");t(this,"onNewStream");t(this,"newStream",e=>{let i=f.generateUniqueId();return new y((s,a)=>{this.iterators.push({id:i,update:s,done:a});let c=this.onNewStream?.(e);if(e?.replay==="latest"){let d=c?.latest??this.latestValue;if(d)s(d);else throw new p.Implementation('ServiceEventEmitter needs a "latest" value, but nothing has been emitted or returned by the onNewStream callback')}else if(c)throw new p.Implementation(`ServiceEventEmitter received a "latest" value from the onNewStream callback for a stream that didn't need it`)},()=>{let s=this.iterators.findIndex(a=>a.id===i);if(s>=0)this.iterators.splice(s,1);else throw new p.BadRequest(`ServiceEventEmitter couldn't find cancelled iterator with id: ${i}`)})});t(this,"iterators",[]);t(this,"latestValue");t(this,"emit",e=>{this.hook?.(e),this.latestValue=e;for(let i of this.iterators)i.update(e)});t(this,"latest",()=>this.latestValue);t(this,"hasStreams",()=>this.iterators.length>0)}setHook(e){this.hook=e}},y=class{constructor(e,i){this.onIteratorEnd=i;t(this,"log",v.log.extend("ServiceStreamIterator"));t(this,"hasAsyncIterator",!1);t(this,"updatesBeforeAsyncIterator",[]);t(this,"onUpdate");t(this,"doneResult",{done:!0,value:void 0});t(this,"promises",[]);t(this,"returnedNextPromise");t(this,"update",e=>{let{hasAsyncIterator:i,updatesBeforeAsyncIterator:s,promises:a,returnedNextPromise:c}=this;if(!i){if(!e||e instanceof p)throw new p.BadRequest("ServiceStream received return or throw before being read");s.push(e);return}let d=a[this.promises.length-1];if(e&&d===void 0){if(!c){this.log.warn("lastPromise and returnedNextPromise should never both be undefined");return}d=c}if(e===void 0)d?.resolve(this.doneResult),c?.resolve(this.doneResult);else if(e instanceof p)c?.reject(e);else{if(this.onUpdate?.(e).ignore)return;a.push(f.newResolvablePromise()),d?.resolve({done:!1,value:e})}});t(this,"next",async()=>{let e=this.promises.shift();return this.returnedNextPromise=e,e||this.doneResult});t(this,"return",async()=>(this.update(void 0),this.onIteratorEnd?.(),this.doneResult));t(this,"throw",async e=>(this.update(e),this.onIteratorEnd?.(),this.doneResult));t(this,"read",async e=>{let i=this[Symbol.asyncIterator](),s=await i.next();for(;!s.done;)e(s.value),s=await i.next()});t(this,"cancel",async()=>{await this.return()});this.promises=[f.newResolvablePromise()],e(this.update,this.update)}[Symbol.asyncIterator](e){if(this.hasAsyncIterator)throw new Error("ServiceStreamIterator.asyncIterator() may only be called once");return this.onUpdate=e,this.hasAsyncIterator=!0,this.updatesBeforeAsyncIterator.forEach(this.update),this.updatesBeforeAsyncIterator=[],this}};export{v as a,x as b,p as c,O as d,f as e,C as f};
//# sourceMappingURL=https://app.framerstatic.com/chunk-66XIMNKS.mjs.map
