import{a as m,b as O,c as o,e as y}from"https://app.framerstatic.com/chunk-66XIMNKS.mjs";import{j as n}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";var l;(s=>{s.onewayRequestId="oneway",s.onewayStreamResponseIdPrefix="#oneway:";let t;(c=>(c.Request="request",c.Response="response",c.Error="error"))(t=s.MessageType||={});function r(i){return typeof i!="object"?!1:i.type==="request"||i.type==="response"||i.type==="error"}s.isMessage=r})(l||={});var M;(t=>{function d(r){if(!r)return!1;switch(r.replay){case"latest":case void 0:break;default:return!1}return!0}t.isServiceStreamOptions=d;class e{constructor(s,i,a){this.method=s;this.options=i;this.helper=a;n(this,"oneway");n(this,"onewayCallback");n(this,"iterator");n(this,"cancelled",!1);n(this,"resolveCancelPromise");n(this,"rejectCancelPromise");this.oneway=i?.oneway??!1}[Symbol.asyncIterator](){if(this.oneway)throw new o.BadRequest("Cannot read a oneway stream through an AsyncIterator. Use read() with a void callback instead.");return this.iterator=this.newIterator(),this.iterator}async read(s){for(this.iterator=this.newIterator(),this.oneway&&(this.onewayCallback=i=>{if(!E(i))throw new o.BadResponse("StreamReader.onewayCallback received an invalid iterator result");if(i.done)return;if(s(i.value))throw new o.BadRequest("ServiceStream callbacks cannot be async if oneway = true.")});;){let i=await this.iterator.next();if(i.done)return;await s(i.value)}}async cancel(){this.cancelled=!0,await this.iterator?.return?.()}newIterator(){if(this.iterator)throw new o.BadRequest("ServiceStream instances can only be read once. If multiple AsyncIterators or read() calls are required, create a new stream for each by calling the associated service method. To broadcast events with an observer pattern, consider using a client-specific EventEmitter or similar.");let s=y.generateUniqueId(),i={done:!0,value:void 0},a=async v=>{if(!E(v))throw new o.BadResponse("StreamReader.next received an invalid iterator result for next()");return v},u=async()=>{try{let v=await this.helper({method:this.method,argument:this.options,stream:{id:s,method:"next"}},this.onewayCallback);return await a(v)}catch(v){throw this.cancelled=!0,v}},c=async()=>(this.cancelled||await new Promise((v,f)=>{this.resolveCancelPromise=v,this.rejectCancelPromise=f}),i);return{next:async()=>this.cancelled?i:Promise.race([u(),c()]),return:async()=>(this.cancelled=!0,this.resolveCancelPromise?.(),this.helper({method:this.method,stream:{id:s,method:"return"}}),i),throw:async v=>(this.cancelled=!0,this.rejectCancelPromise?.(v),this.helper({method:this.method,stream:{id:s,method:"return"}}),i)}}}t.StreamReader=e})(M||={});function E(d){return d?d.done===!0||d.done===!1&&d.value!==void 0:!1}var R=class{constructor(e){this.log=e;n(this,"expectWithoutDiscovery",(e,t)=>this.addRouter(t).expectWithoutDiscovery(e));n(this,"discover",async(e,t,r={})=>this.addRouter(t).discover(e,r));n(this,"unregister",async e=>{let t=[];for(let r of this.routers)r.channel===e&&t.push(r);if(t.length>0)for(let r of t)await r.unregisterAllImplementations(),this.routers.delete(r),r.destroy();else for(let r of this.routers)await r.unregisterImplementation(e)});n(this,"routers",new Set);n(this,"addRouter",e=>{for(let r of this.routers)if(r.channel===e)return r;let t=new C(e,this.log);return this.routers.add(t),t});n(this,"testable",{onlyRouter:()=>{if(this.routers.size!==1)throw new Error(`onlyRouter called on a ServiceManager with ${this.routers.size} routers, expected 1`);return this.routers.values().next().value}})}register(e){function t(r){return"service"in r&&"implementation"in r&&r.service!==void 0&&r.implementation!==void 0}return t(e)?(this.addRouter(e.channel).registerImplementation(e.implementation,e.service),()=>void this.unregister(e.implementation)):(this.addRouter(e.channel),()=>void this.unregister(e.channel))}};(t=>{let d;function e(){return d=d??new t,m._sharedServiceManagerIfTesting()??d}t.shared=e})(R||={});var C=class{constructor(e,t){this.channel=e;this.customLogger=t;n(this,"onMessage",e=>{try{e.type===l.MessageType.Request?e.id===l.onewayRequestId?this.onOnewayRequest(e):this.onRequest(e):e.type===l.MessageType.Response?e.method===g.method?this.onDiscoveryResponse(e):this.onResponse(e):e.type===l.MessageType.Error?this.onErrorResponse(e):O(e.type,new Error(`Unknown message: ${JSON.stringify(e)}`))}catch(t){this.log.reportError(t,{message:e})}});n(this,"latestDiscoveryInfo");n(this,"waitingDiscoveryMap",{});n(this,"reflectDiscoveredServices",()=>{let e=this.latestDiscoveryInfo?Object.keys(this.latestDiscoveryInfo.services):[],t;this.channel.disabled&&(e=Object.keys(this.waitingDiscoveryMap),t=new o.ServiceNotFound);for(let r of e){let s=this.waitingDiscoveryMap[r];s&&(this.waitingDiscoveryMap[r]=[],s.forEach(i=>t?i.reject(t):i.resolve()))}});n(this,"onDiscoveryResponse",e=>{if(g.isValidInfo(e.body))this.latestDiscoveryInfo=e.body,this.reflectDiscoveredServices(),this.log.trace("\u2198\uFE0F Discovered services",e.body);else throw new o.BadResponse("Invalid discovery response",e);e.id!==g.broadcastMessageId&&this.onResponse(e)});n(this,"broadcastDiscoveryInfo",e=>{let t={};for(let[s,i]of Object.entries(this.implementedServices)){let a=i.service;t[s]={fingerprint:a.fingerprint}}let r={services:t};try{this.channel.postMessage({type:l.MessageType.Response,id:e||g.broadcastMessageId,serviceId:g.serviceId,method:g.method,body:r})}catch{}});n(this,"onewayPromise",Promise.resolve(void 0));n(this,"expectWithoutDiscovery",e=>(this.log.trace("\u260E\uFE0F expectWithoutDiscovery",e.id),e.newOutgoingWrapper(async(t,r)=>t.oneway?(this.postOnewayRequest(e.id,t),this.onewayPromise):(await this.waitForDiscoveryInfo(1e3),this.throwErrorIfBadService(e),this.postRequest(e.id,t,void 0,r)))));n(this,"discover",async(e,{timeout:t=3e4}={})=>{this.log.trace("\u260E\uFE0F discover",e.id);let r=[this.waitForDiscoveredService(e,t)];return t!==1/0&&r.push(D(t).then(()=>{throw this.latestDiscoveryInfo?new o.ServiceNotFound(e.id):new o.TimedOut(e.id)})),await Promise.race(r),this.throwErrorIfBadService(e),this.expectWithoutDiscovery(e)});n(this,"throwErrorIfBadService",e=>{let t=this.latestDiscoveryInfo,r=t&&t?t.services[e.id]:void 0;if(!r)throw this.log.warn("\u260E\uFE0F Couldn't find service",e.id,t),new o.ServiceNotFound(e.id);if(r.fingerprint!==e.fingerprint)throw this.log.warn("\u260E\uFE0F Couldn't find service with required version fingerprint. Make sure both endpoints are using the same version of the Services package.",t),new o.ServiceNotCompatible(e.id)});n(this,"postOnewayRequest",(e,t)=>{this.channel.postMessage({type:l.MessageType.Request,id:l.onewayRequestId,serviceId:e,method:t.method,body:t.argument})});n(this,"postRequest",(e,t,r,s)=>{if(this.log.trace("\u2197\uFE0F",e,t),!!(this.channel.disabled??!1))return Promise.reject(new o.ServiceNotFound(e));let a={type:l.MessageType.Request,id:y.generateUniqueId(),serviceId:e,method:t.method,stream:T.toMessage(t.stream),body:t.argument},u=y.newResolvablePromise();this.waitingRequestsMap[a.id]={result:u,onStreamValue:s},this.channel.postMessage(a);let c=[u];return typeof r=="number"&&c.push(D(r).then(()=>{throw new o.TimedOut})),Promise.race(c).then(v=>v?.body).catch(v=>{throw delete this.waitingRequestsMap[a.id],v})});n(this,"waitingRequestsMap",{});n(this,"onResponse",e=>{let t=e.id,r=t.startsWith(l.onewayStreamResponseIdPrefix);r&&(t=t.substr(l.onewayStreamResponseIdPrefix.length));let s=this.waitingRequestsMap[t];if(r)s&&e.body&&s.onStreamValue?.(e.body);else{if(!s)return this.log.warn("\u260E\uFE0F onResponse: couldn't find request",e);delete this.waitingRequestsMap[t],s.result.resolve(e)}});n(this,"onErrorResponse",(e,t)=>{let r=this.waitingRequestsMap[e.id];if(!r)return this.log.warn("\u260E\uFE0F onErrorResponse: couldn't find request",e);delete this.waitingRequestsMap[e.id];let s=t||o.reconstructErrorResponse(e.body);r.result.reject(s)});n(this,"implementedServices",{});n(this,"unregisteredServices",new Set);n(this,"registerImplementation",(e,t)=>{this.log.trace("\u260E\uFE0F registerImplementation",t.id,e);let r={};for(let s in t.methods){let i=s,a=e[i];if(typeof a!="function")throw new o.Implementation(`Implementation for ${t.id} doesn't correctly implement ${i}()`);r[i]=a.bind(e)}this.unregisteredServices.delete(t.id),this.implementedServices[t.id]={service:t,rawImplementation:e,implementation:Object.freeze(r)},this.broadcastDiscoveryInfo()});n(this,"unregisterImplementation",async e=>{let t=e===this.unregisterAllToken;t||this.log.trace("\u260E\uFE0F unregisterImplementation",e);let r=!1,s=[];for(let[i,a]of Object.entries(this.implementedServices))if(!(!t&&a.rawImplementation!==e)){this.unregisteredServices.add(i),delete this.implementedServices[i],r=!0;for(let[u,c]of Object.entries(this.requestedStreamsMap))c?.serviceId===i&&s.push({id:u,error:new o.ServiceGone(i)})}await this.cancelStreams(s),r&&this.broadcastDiscoveryInfo()});n(this,"unregisterAllToken",{});n(this,"unregisterAllImplementations",async()=>{this.log.debug("\u260E\uFE0F unregisterAllImplementations"),await this.unregisterImplementation(this.unregisterAllToken)});n(this,"requestedStreamsMap",{});n(this,"cancelStreams",async e=>{let t=[];for(let{id:r,error:s}of e){let i=this.requestedStreamsMap[r];delete this.requestedStreamsMap[r],i?.iterator.throw&&t.push(i.iterator.throw(s))}await Promise.all(t)});n(this,"onRequest",async e=>{if(e.method===g.method){this.broadcastDiscoveryInfo(e.id);return}let t=l.MessageType.Response,r,s=!1;try{let i=this.implementedServices[e.serviceId],a=i?.implementation;if(!a)throw this.unregisteredServices.has(e.serviceId)?new o.ServiceGone(e.serviceId):new o.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let u=a[e.method];if(!e.stream)r=await u(e.body);else{let{id:c,method:v}=T.fromMessage(e.stream),f=this.requestedStreamsMap[c];if(v==="next"){if(!f){let p=M.isServiceStreamOptions(e.body)?e.body:void 0;f={iterator:(await u(p))[Symbol.asyncIterator](p?.oneway?q=>(this.channel.postMessage({type:l.MessageType.Response,id:l.onewayStreamResponseIdPrefix+e.id,serviceId:e.serviceId,method:e.method,body:{done:!1,value:q}}),{ignore:!0}):void 0),serviceId:i.service.id},this.requestedStreamsMap[c]=f}try{let p=await f.iterator.next();r={done:p.done,value:p.value}}catch(p){throw s=p instanceof o.ServiceGone,p}}else if(v==="return"){delete this.requestedStreamsMap[c];let p=f?.iterator.return;p&&await p(),r={done:!0,value:void 0}}else throw new o.BadRequest("Stream operations other than next() and return() are not yet supported")}}catch(i){t=l.MessageType.Error,r=o.toMessageBody(i),s||this.log.warn("\u260E\uFE0F onRequest: error",e,i)}finally{this.channel.postMessage({type:t,id:e.id,serviceId:e.serviceId,method:e.method,body:r})}});n(this,"onOnewayRequest",e=>{try{let r=this.implementedServices[e.serviceId]?.implementation;if(!r)throw this.unregisteredServices.has(e.serviceId)?new o.ServiceGone(e.serviceId):new o.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let s=r[e.method];s(e.body)}catch(t){this.log.warn("\u260E\uFE0F onOnewayRequest: error",e,t)}});n(this,"testable",{waitingRequestsMap:()=>this.waitingRequestsMap});e.addMessageListener(this.onMessage)}get log(){return this.customLogger??m.log}destroy(){this.channel.removeMessageListener(this.onMessage)}async waitForDiscoveryInfo(e,t=0){if(this.latestDiscoveryInfo)return this.latestDiscoveryInfo;let r=e/(t+1),s=0;for(;s<=t;)try{await this.postRequest(g.serviceId,{method:g.method},r);break}catch(i){if(!(i instanceof o.TimedOut))throw i;if(!this.isWaitingForDiscovery())break;s++}if(!this.latestDiscoveryInfo)throw new o.ServiceNotFound;return this.latestDiscoveryInfo}isWaitingForDiscovery(){return Object.values(this.waitingDiscoveryMap).some(e=>e&&e.length>0)}async waitForDiscoveredService(e,t){let r=y.newResolvablePromise(),s=this.waitingDiscoveryMap[e.id]||[],i=this.isWaitingForDiscovery();return this.waitingDiscoveryMap[e.id]=s,s.push(r),i||this.waitForDiscoveryInfo(t,2).catch(()=>{}),this.reflectDiscoveredServices(),r}},g;(s=>{s.serviceId="",s.method="#discover",s.broadcastMessageId="";function r(i){return!!(i&&typeof i=="object"&&"services"in i&&typeof i.services=="object")}s.isValidInfo=r})(g||={});var T;(s=>{let d="#return:",e="#throw:";function t(i){return i.startsWith(d)?{id:i.substr(d.length),method:"return"}:i.startsWith(e)?{id:i.substr(e.length),method:"throw"}:{id:i,method:"next"}}s.fromMessage=t;function r(i){if(i)switch(i.method){case"next":return i.id;case"return":return d+i.id;case"throw":return e+i.id;default:return}}s.toMessage=r})(T||={});function D(d){return new Promise(e=>{setTimeout(e,d)})}var x=class{constructor(){n(this,"listeners",new Set)}get log(){return m.log.extend("LocalChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.listeners.forEach(t=>t(e))}addMessageListener(e){this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e)}},Z=new x;var k=class{constructor(e){this.port=e;n(this,"listeners",new Set);n(this,"onMessageEvent",e=>{this.log.trace(e);let t=e.data;if(l.isMessage(t))for(let r of this.listeners)r(t)})}get log(){return m.log.extend("MessagePortChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.port.postMessage(e)}addMessageListener(e){this.listeners.size===0&&(this.port.start(),this.port.addEventListener("message",this.onMessageEvent,!1)),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&this.port.removeEventListener("message",this.onMessageEvent,!1)}};var h=typeof window>"u"?void 0:window,I="data:origin-not-initialized",S=class S{constructor(e,t){this.target=e;n(this,"trustedOrigin",I);n(this,"disabled");n(this,"listeners",new Set);n(this,"onMessageEvent",e=>{this.log.trace(e.data,e.origin);let t=!1;if(e.source!==this.target)if(this===w&&e.source===h&&e.data?.__sourceRepresentsParentFrame)t=!0;else return;if(!t&&e.origin!==this.trustedOrigin&&this.trustedOrigin!=="*")throw this.trustedOrigin?new Error(`PostMessageChannel received a message with origin ${e.origin}, expected ${this.trustedOrigin}`):new Error(`PostMessageChannel received a message with origin ${e.origin}, but has not been configured with initializeTrustedOrigin`);if(this.interceptor?.handleRawEvent(e))return;let r=e.data;if(l.isMessage(r))for(let s of this.listeners)s(r)});n(this,"interceptor");let r=S.targetRepresentingParentFrame;if(e===(h?h.parent:void 0)||e===r){if(!P||w!==void 0)throw new Error("PostMessageChannel.toParentFrame must be used instead of initializing with window.parent.");if(h)h.parent!==h?this.target=h.parent:(this.target=r,this.disabled=r.disabled);else{this.target={postMessage:(...s)=>{this.log.debug("postMessage to parent channel not running in a DOM environment: ",s)}};return}}t!==I&&this.initializeTrustedOrigin(t)}get log(){return m.log.extend("PostMessageChannel")}static get toParentFrame(){return P=!0,w=w??new S(S.targetRepresentingParentFrame,I),P=!1,w}initializeTrustedOrigin(e){if(this.trustedOrigin!==I&&!(this===w&&e===this.trustedOrigin))throw new Error("PostMessageChannel can only be initialized with a trusted origin once");if(e!=="*"){if(!e.includes("://"))throw new Error(`PostMessageChannel can only be initialized with a concrete origin (https://...); received ${e}`)}this.trustedOrigin=e}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.target.postMessage(e,this.trustedOrigin)}postMessageRaw(e){this.target.postMessage(e,this.trustedOrigin)}addMessageListener(e){this.listeners.size===0&&h?.addEventListener("message",this.onMessageEvent,!1),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&h?.removeEventListener("message",this.onMessageEvent,!1)}static interceptMessageEventsFromOpenerFrame(e){L.setInterceptor(e)}setInterceptor(e){this.interceptor&&this.removeMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting),this.interceptor=e?{handleRawEvent:e,unusedMessageListenerOnlyForCounting:()=>{}}:void 0,this.interceptor&&this.addMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting)}};n(S,"targetRepresentingParentFrame",(()=>{let e="__targetRepresentingParentFrame",t=h?.[e]??h?.webkit?.messageHandlers?.[e];return{disabled:!t,postMessage:(...r)=>{if(h){if(!t)throw new Error(`Can't find window.parent or ${e} message handler`)}else throw new Error("PostMessageChannel requires a DOM environment");t.postMessage(...r)}}})());var b=S,P=!1,w,B=b.toParentFrame,L=h&&h.opener&&h!==h.opener&&h.parent===h?new b(h.opener,I):B;var F;(s=>{function d(i,a,u,c){u({method:i,argument:a?c:void 0,oneway:!0})}s.onewayMethodTemplate=d;async function e(i,a,u,c){await u({method:i,argument:a?c:void 0})}s.voidMethodTemplate=e;async function t(i,a,u,c){return await u({method:i,argument:a?c:void 0})}s.valueMethodTemplate=t;function r(i,a,u){return new M.StreamReader(i,u,a)}s.streamMethodTemplate=r})(F||={});export{R as a,Z as b,k as c,b as d,B as e,L as f,F as g};
//# sourceMappingURL=https://app.framerstatic.com/chunk-ORIFM75E.mjs.map
